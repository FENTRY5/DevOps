Question 1
How do you set a custom path for Terraform Logging via environment variable?

LOG_FILE=/path/to/my.log

TF_LOG_FILE=/path/to/my.log

TF_LOG=/path/to/my.log

This is a valid environment variable, but it's for setting the severity of the log

https://www.terraform.io/docs/cli/config/environment-variables.html#tf_log
`export TF_LOG_PATH=./terraform.log`

TF_LOG_PATH=/path/to/my.log*

This specifies where the log should persist its output to. Note that even when TF_LOG_PATH is set, TF_LOG must be set in order for any logging to be enabled. For example, to always write the log to the directory you're currently running terraform from:

https://www.terraform.io/docs/cli/config/environment-variables.html#tf_log_path
==========

Question 2
What does the following module versioning mean?

version = ">= 1.2.0, < 2.0.0"
less than 2.0.0

greater than or equal to 1.2.0

less than or equal to 1.2.0 but greater than 2.0.0

greater than or equal to 1.2.0 but less than 2.0.0

SELECTED
https://www.terraform.io/docs/language/expressions/version-constraints.html#version-constraint-syntax
===============

Question 3
terraform init _____ will get the latest version of plugins that complies with the configuration's version constraints

-update-plugins

There is no such flag

-get-plugins

This is a flag but its used to skip plugins

-get-plugins=false

-update

There is no such flag

-upgrade

SELECTED
-upgrade Upgrade all previously-selected plugins to the newest version that complies with the configuration's version constraints. This will cause Terraform to ignore any selections recorded in the dependency lock file, and to take the newest available version matching the configured version constraints.

https://www.terraform.io/docs/cli/commands/init.html#plugin-installation
======

Question 4
Which is NOT a valid Terraform Module source?

S3 Bucket

https://www.terraform.io/docs/language/modules/sources.html#s3-bucket

HTTP Archive

https://www.terraform.io/docs/language/modules/sources.html#fetching-archives-over-http

HTTP URL

https://www.terraform.io/docs/language/modules/sources.html#http-urls

GCS Bucket

https://www.terraform.io/docs/language/modules/sources.html#gcs-bucket

Azure Blob Storage*

Terraform does not have a Terraform module source for Azure


================

Question 5
Terraform is considered a _________ IaC Tool

Imperative

Declarative

SELECTED
============

Question 6
What are the benefits of Infrastructure as Code (IaC)?

Manual Configuration

Reduced Development Effort


There is a large upfront cost to writing infrastructure as code and training your team. IaC does reduce effort eventual written and reuse previous IaC so with every subsequent project requires less time.

Idempotent*

No matter how many times you run IaC you will always end up with the same state that is expected.

Automation*

IaC allows you to automate your infrastructure because it's all defined within configuration files which can be programmatically used to set up reasonable, predictable and consistent behaviour.

===========
Question 7
What are the two types of backends?

local

SELECTED
The local backend stores state on the local filesystem, locks that state using system APIs, and performs operations locally.

https://developer.hashicorp.com/terraform/language/settings/backends/local

Workspaces

Terraform Cloud

SELECTED
As of Terraform v1.1.0 and Terraform Enterprise v202201-1, HashiCorp recommends using the Terraform Cloud's built-in cloud integration instead of remote. The cloud option includes an improved user experience and more features.

https://developer.hashicorp.com/terraform/language/settings/terraform-cloud

Function Calls

EXPLANATION
Backend Types Terraform has a built-in selection of backends, and the configured backend must be available in the version of Terraform you are using.

https://developer.hashicorp.com/terraform/language/settings/backends/configuration#backend-types
==========

Question 8
A connection block can be nested within a

module

provider

provisioner

SELECTED
resource

SELECTED
EXPLANATION
Connection blocks don't take a block label, and can be nested within either a resource or a provisioner.

A connection block nested directly within a *resource *affects all of that resource's provisioners.
A connection block nested in a provisioner block only affects that provisioner, and overrides any resource-level connection settings
=============

Question 9
Alias is used to define alternate or multiple configurations for the same provider.

Is this statement true?

False

True

SELECTED
You can optionally define multiple configurations for the same provider, and select which one to use on a per-resource or per-module basis. The primary reason for this is to support multiple regions for a cloud platform; other examples include targeting multiple Docker hosts, multiple Consul hosts, etc.

To create multiple configurations for a given provider, include multiple provider blocks with the same provider name. For each additional non-default configuration, use the alias meta-argument to provide an extra name segment. For example:

# The default provider configuration; resources that begin with `aws_` will use
# it as the default, and it can be referenced as `aws`.
provider "aws" {
  region = "us-east-1"
}

# Additional provider configuration for west coast region; resources can
# reference this as `aws.west`.
provider "aws" {
  alias  = "west"
  region = "us-west-2"
}
https://www.terraform.io/docs/language/providers/configuration.html#alias-multiple-provider-configurations
===========

Qu
==========estion 10
What is the scope of Local Values between parent and child modules?

Local values defined in child modules are accessible to any adjacent child module. Local values in the parent module are only accessible to the parent.

Local values defined in the submodules are accessible to the parent but not between adjacent child modules.

Local values defined in the parent are accessible to all the child modules

Local values are scoped for the only current module*

Terraform modules are designed to be isolate. To get any data across modules you have to define inputs and outputs.

EXPLANATION
Child modules and sub-modules are interchangeable terms.
==========

Question 11
How could a developer inject secrets via Vault at the time of terraform apply within their terraform configuration file?

Vault Block

There is no such thing as a vault block

Connection Block

Connection blocks are for provisioners to define how a provisioner should connect eg. SSH

Secrets Block

There is no such block

Data Sources Block

SELECTED
Secrets are injected by using Data Sources:

data "vault_aws_access_credentials" "creds" {
  backend = data.terraform_remote_state.admin.outputs.backend
  role    = data.terraform_remote_state.admin.outputs.role
}

provider "aws" {
  region     = var.region
  access_key = data.vault_aws_access_credentials.creds.access_key
  secret_key = data.vault_aws_access_credentials.creds.secret_key
}
https://github.com/hashicorp/learn-terraform-inject-secrets-aws-vault/blob/master/operator-workspace/main.tf

=============

Question 12
_______("Hello World")
Hello%20World

Fill in the blank for the built-in function.

bcrypt

bcrypt computes a hash of the given string using the Blowfish cipher, returning a string in the Modular Crypt Format usually expected in the shadow password file on many Unix systems.

> bcrypt("hello world")
$2a$10$D5grTTzcsqyvAeIAnY/mYOIqliCoG7eAMX0/oFcuD.iErkksEbcAa
sanitize

No such built-in function.

format

SELECTED
format produces a string by formatting a number of other values according to a specification string. It is similar to the printf function in C, and other similar functions in other programming languages.

> format("Hello, %s!", "Ander")
Hello, Ander!
> format("There are %d lights", 4)
There are 4 lights

urlencode*

urlencode applies URL encoding to a given string.

> urlencode("Hello World")
Hello%20World
==============
Question 13
The following dynamic block will result in an error, what is the problem?

dynamic "setting" {
    content {
      namespace = setting.value["namespace"]
      name = setting.value["name"]
      value = setting.value["value"]
    }
  }
An iterator argument is missing

The iterator argument (optional) sets the name of a temporary variable that represents the current element of the complex value. If omitted, the name of the variable defaults to the label of the dynamic block ("setting" in the example above).

content should be called for_each

This is not true.

content block is not necessary

The nested content block defines the body of each generated block. You can use the temporary iterator variable inside this block.

Content block is required

for_each is missing

SELECTED
The dynamic block requires a for_each:

  dynamic "setting" {
    for_each = var.settings
    content {
      namespace = setting.value["namespace"]
      name = setting.value["name"]
      value = setting.value["value"]
    }
The for_each argument provides the complex value to iterate over.

EXPLANATION
https://www.terraform.io/docs/language/expressions/dynamic-blocks.html
============

Question 14
When using a build server or Terraform cloud to run Terraform apply how should you input configuration or secrets?

Encrypt configuration variables in a tfvars file and commit file to the codebase

This is a possibility but again if someone were to access your codebase they would have the file containing your secrets, they would need to obtain the key to decrypt it. A better solution is to store your variables in a secrets database and then pull them at the time of use and load them as Env Vars.

Commit the configuration variables values to the codebase.

No, this is the most dangerous thing you can do.

Using the -var with CLI command

It's possible but would not be efficient and could expose sensitive values to an output log.

Use Environment Variables

SELECTED
Passing Env Vars is the ideal way or the only possible way when working with Terraform Cloud or a build server.

https://www.terraform.io/docs/cli/config/environment-variables.html#tf_var_name

EXPLANATION
https://blog.gruntwork.io/a-comprehensive-guide-to-managing-secrets-in-your-terraform-code-1d586955ace1
=============

Question 15
When you need to manage multiple Terraform Cloud workspaces you can set the following configuration in your backend block.

envs {
  prefix = "app-"
}
workspaces {
  env "prod"  { 
    path = "./prod.tfstate"
  }

  env "dev"    {
    path = "./dev.tfstate"
  }
  env "demo" {
    path = "./demo.tfstate"
  }
}


workspaces {
  env = ["dev","prod","demo"]
}

*workspaces {
  prefix = "app-"
}
You can set up multiple workspaces by using the prefix flag. When you run terraform apply it will ask to you choose which workspace you want to deploy.

https://www.terraform.io/docs/language/settings/backends/remote.html#configuration-variables

https://www.terraform.io/docs/cloud/migrate/workspaces.html#step-5-edit-the-backend-configuration

===========

Question 16
When terraform locks its state it creates a dependency lock file called .terraform.lock?

True

False*

The lock file is always named .terraform.lock.hcl, and this name is intended to signify that it is a lock file for various items that Terraform caches in the .terraform subdirectory of your working directory.

https://www.terraform.io/docs/language/dependency-lock.html#lock-file-location

While the question may not feel fair, the actual exam will test on the exam naming of files, So its reflective of the actual exam.

============

Question 17
What does the triggers block do for null_resource?

triggers a notification to the HTTP endpoint

resource "empty_resource" "cluster" {
  # ...
}
triggers an action if it succeeds or fails to provision.

Allows you to chain multiple Terraform workspaces together

Terraform Cloud workspaces do have a feature called triggers which is for chaining together multiple Terraform Cloud workspaces.

triggers provisioners to re-run*


triggers - A map of values that should cause this set of provisioners to re-run. Values are meant to be interpolated references to variables or attributes of other resources.

https://www.terraform.io/docs/language/resources/provisioners/null_resource.html#argument-reference

==============

Question 18
Which of the following backend configuration for Terraform Cloud is correct for multiple environments/workspaces?

terraform {
  backend "terraform_cloud" {
    organization = "company"
  }
  workspaces = ["prod","dev"]
}
When using terraform cloud you specific remote. Workspaces is a block. It does not take a list.

terraform {
  backend "remote" {
    hostname = "cloud.terraform.com"
    organization = "company"
  }
  workspaces {
     name = "my-app"
  }
}
Terraform Cloud is hosted on app.terraform.io

When you want multiple workspaces (environments) you use prefix not name.

terraform {
  backend "remote" {
    hostname = "app.terraform.io"
    organization = "company"
  }
  workspaces {
     name = "my-app"
  }
}
When you want multiple workspaces (environments) you use prefix not name.

terraform {
  backend "remote" {
    hostname = "app.terraform.io"
    organization = "company"
  }
  workspaces {
     prefix= "my-app-"
  }
}
SELECTED
This is correct, when you want to use multiple workspaces you use the prefix command

EXPLANATION
Workspaces used to be called environments and are commonly thought of as environments. We called it environments to be a distractor.

https://www.terraform.io/language/settings/backends/remote#basic-configuration
=============

Question 19
When searching for modules in Terraform Registry only verified or official modules will appear?

No, it will show verified, official and unverified

No, only official

Yes, only verified or official*

EXPLANATION
https://registry.terraform.io/browse/modules
========

Question 20
What is the version constraint for this provider?

terraform {
  required_providers {
    mycloud = {
      source  = "mycorp/mycloud"
      version = "~> 1.0"
    }
  }
}
Compare against a specific version

Excludes an exact version number

Match exact version num

Allow only the rightmost version to increment

SELECTED
tilde arrow eg. ~>

Allow only the rightmost version (last number) to increment

https://www.terraform.io/docs/language/expressions/version-constraints.html

EXPLANATION
A version constraint is a string containing one or more conditions, separated by commas.

= or no operator. Match exact version number e.g. “1.0.0”, “=1.0.0”
!= Excludes an exact version number e.g. “!=1.0.0”
> >= < <= Compare against a specific version e.g. “>= 1.0.0”
~> Allow only the rightmost version (last number) to increment e.g. ~> 1.0.0”
===========

Question 21
When declaring a required_providers

terraform {
  required_providers {
    mycloud = {
      source  = "mycorp/mycloud"
      version = "~> 1.0"
    }
  }
}
What will be the provider name eg:

provider " __________ " {
  # ...
}
mycorp

mycloud#1.0

mycorp/mycloud

mycloud

SELECTED
Local names are module-specific, and are assigned when requiring a provider. Local names must be unique per-module.

Outside of the required_providers block, Terraform configurations always refer to providers by their local names. For example, the following configuration declares mycloud as the local name for mycorp/mycloud, then uses that local name when configuring the provider:

terraform {
  required_providers {
    mycloud = {
      source  = "mycorp/mycloud"
      version = "~> 1.0"
    }
  }
}

provider "mycloud" {
  # ...
}
https://www.terraform.io/docs/language/providers/requirements.html#local-names
============

Question 22
As a developer, can I create my own user-defined functions in Terraform?

Yes, Terraform allows you to create user-defined functions via modules.

No, Terraform does not support user-defined functions

SELECTED
The Terraform language does not support user-defined functions, so only the functions built into the language are available for use.

https://www.terraform.io/docs/language/functions/index.html

============
Question 23
What command is used to change to a different workspace?

You can only change workspace via Terraform Cloud

This is not true

terraform workspace change

This subcommand does not exist

terraform workspace switch

This subcommand does not exist

terraform workspace select

SELECTED
The terraform workspace select command is used to choose a different workspace to use for further operations.

https://www.terraform.io/docs/cli/commands/workspace/select.html
===========

Question 24
Which Terraform Workflow ( Write -> Plan -> Create ) does this describe?

Check out a project from repo, and start writing code in a new branch
When making changes write commits to the new branch and submit a Pull Request
When the pull request is merged, a build server performs terraform apply

Core Workflow Enhanced

https://www.terraform.io/guides/core-workflow.html#the-core-workflow-enhanced-by-terraform-cloud

Individual Practitioner Workflow

https://www.terraform.io/guides/core-workflow.html#working-as-an-individual-practitioner

Team Workflow*

https://www.terraform.io/guides/core-workflow.html#working-as-a-team
========

Question 25
Provisioners should only be used as a last resort, Terraform strongly recommends creating build images.

False

True*
===========

Question 26
What does AWS CloudFormation, Azure Resource Manager and Google Deployment Manager have in common?

They are imperative tools

Imperative is when you use a programming language like Ruby, Python, Java....

They can deploy to any cloud provider

They can only deploy to their own cloud services.

They are declarative tools

SELECTED
All providers either use JSON or YAML files which are declarative.

They utilize the best practices of IaC

SELECTED
==========
Question 27
terraform fmt will check if the required attributes are present and the correct types are used for values

True

False*

The terraform fmt command is used to rewrite Terraform configuration files to a canonical format and style. It does not validate the configuration file itself. Terraform validate would do this.

https://www.terraform.io/docs/cli/commands/fmt.html

============

Question 28
Infrastructure as Code allows for teams to share infrastructure configuration across their entire organization.

False

True*

Since its just a collection of configuration files, they can be shared like code.

===========
Question 29
What will happen when terraform destroy is performed?

It will list all the resources without actually destroying them.

Running terraform destroy does not list resources without destroying them. It is an action explicitly intended for resource destruction. When you run terraform destroy, Terraform will attempt to destroy all the resources it's aware of in the configuration by interacting with the underlying infrastructure provider (e.g., AWS, Azure, Google Cloud). It doesn't generate a list of resources without taking any destructive actions.

It will prompt you to select which infrastructure to destroy, pressing Enter will default to all infrastructure.

SELECTED
By default, terraform destroy does not prompt you for individual resource destruction. It assumes that you want to destroy all the resources it's aware of in the configuration. While Terraform does have interactive confirmations for certain destructive operations (e.g., when using -auto-approve=false), it doesn't provide a selective prompt to choose which resources to destroy.

It will only destroy resources that were created within the last 24 hours.

Terraform's destroy operation is not time-based. It doesn't have a built-in mechanism to determine when resources were created or when they should be destroyed based on a specific timeframe. terraform destroy will attempt to destroy all the resources defined in the configuration and tracked in the state file, regardless of their age.

It will destroy all provisioned cloud infrastructure found within the state file.*

When you run terraform destroy, Terraform reads the state file to determine which resources it has provisioned. It then proceeds to destroy all the resources it finds in the state file. So, this statement accurately describes what terraform destroy does.

https://www.terraform.io/docs/cli/commands/destroy.html
========


Question 30
Which of the following is a valid terraform import command:

terraform import resource.aws_instance.foo i-abcd1234
terraform import 'aws_instance.baz[0]' i-abcd1234
https://www.terraform.io/docs/cli/commands/import.html#example-import-into-resource-configured-with-count

The example below will import an AWS instance into the first instance of the aws_instance resource named baz configured with count:

$ terraform import 'aws_instance.baz[0]' i-abcd1234*  SELECTED
terraform import aws_instance.foo address _id=i-abcd1234

The format of this command is incorrect. The resource identifier should come after the resource name, and you don't need to specify address or _id in the command.

terraform import aws_instance.foo module=foo
The format of this command is incorrect. You should provide the resource identifier (e.g., i-abcd1234) after the resource name, not module=foo.


terraform import module.foo.aws_instance.bar i-abcd1234
SELECTED
https://www.terraform.io/docs/cli/commands/import.html#example-import-into-module

$ terraform import module.foo.aws_instance.bar i-abcd1234
terraform import aws_instance.foo i-abcd1234
SELECTED
https://www.terraform.io/docs/cli/commands/import.html#example-import-into-resource

The example below will import an AWS instance into the aws_instance resource named bar into a module named foo:

$ terraform import aws_instance.bar i-abcd1234
===============

Question 31
Does the Terraform Registry only show search results for verified modules?

No

Yes

SELECTED
By default, only verified modules are shown in search results. Verified modules are reviewed by HashiCorp to ensure stability and compatibility. By using the filters, you can view unverified modules as well.

Technically both Offical and Verified will show in search results. But on the exam, they might just ask if it's only Verified based on the docs.

https://www.terraform.io/docs/registry/modules/use.html#finding-modules
======


Question 32
A Terraform configuration file has a child module that defines AWS Virtual Private Cloud (VPC) resources.

The DevOps Engineer wants to expose these values to the CLI.

How would this be achieved?

Outputs only need to be defined if you want to provide a description or mark outputs as sensitive. All resources attributes can be accessed via the outputs CLI by default.

This is not true. Outputs can only access values defined in a outputs definition block.

Output modules only need to be defined in the parent module

To access child modules outputs they need to be defined in the child and then referenced in the parent module ouputs.

Outputs need to be defined in only the child module. Outputs CLI command can access any child module

Outputs CLI commands can not infer outputs from child modules. They need to be defined again in the parent module and referencing the child module.

Outputs need to be defined in both the parent and child module

SELECTED
Yes, you first define your outputs for your VPC in the child module. Then in your parent module, you reference your child module.

A child module can use outputs to expose a subset of its resource attributes to a parent module.
A root module can use outputs to print certain values in the CLI output after running terraform apply.
https://www.terraform.io/docs/language/values/outputs.html
==========

Question 33
terraform plan must be run before perform terraform apply.

True

False

SELECTED
In the default case, with no saved plan file, terraform apply creates its own plan of action, in the same way that terraform plan would.

https://www.terraform.io/docs/cli/commands/apply.html#automatic-plan-mode
===========

Question 34
A remote backend cannot perform operations because a remote backend is a third-party storage for your state file like Amazon S3 and does not have computing capabilities of running Terraform.

Is this statement true?

True

False

SELECTED
It is true that the backend for Amazon S3 cannot execute Terraform operations.

A remote backend is Terraform Cloud which can execute Terraform operations

A third-party storage is a Standard Backend.

"The remote backend is unique among all other Terraform backends because it can both store state snapshots and execute operations for Terraform Cloud's CLI-driven run workflow. It used to be called an "enhanced" backend.

When using full remote operations, operations like terraform plan or terraform apply can be executed in Terraform Cloud's run environment, with log output streaming to the local terminal. Remote plans and applies use variable values from the associated Terraform Cloud workspace."

https://www.terraform.io/language/settings/backends/remote

https://www.terraform.io/docs/language/settings/backends/index.html#backend-types
==========

Question 35
Using resource addressing, select the third instance in the cluster of virtual machines:

resource "aws_instance" "web" {
  # ...
  count = 4
}
aws_instance.web.nth(3)

In Resource Addressing you can't use function calls. eg. ()

aws_instance.web[3]

The index starts a 0 so it would actually be 2

aws_instance.web(3)

In Resource Addressing you can't use function calls. eg. ()

aws_instance.web[2]

SELECTED
The index starts a 0 so it would be 2.

0 = 1st instance 1 = 2nd instance 2 = 3rd instance 3 = 4th instance
=========

Question 36
IaC is idempotent, meaning that if you execute the same terraform configuration file you will always end up the same amount of defined resources.

False

True

SELECTED
idempotent means that if I define two Virtual Machines in my IaC file. No matter how many times I deploy/provision. I will always have only two VMs.

===========

Question 37
terraform workspace default will print out to the console the default workspace

True

There is no such command called terraform workspace default

False*

The default workspace is called default. You cannot rename it. You can see it by running a terraform workspace list.

$ terraform workspace list
  default
* development
  jsmith-test
The command will list all existing workspaces. The current workspace is indicated using an asterisk (*) marker.

The persistent data stored in the backend belongs to a workspace. Initially, the backend has only one workspace, called "default", and thus there is only one Terraform state associated with that configuration.
============

Question 38
Terraform allows you to generate a plan before you execute your operation. This is known as ________

Terraform Automation

This does not exist.

Execution Automation

This does not exist.

Plan Automation

This does not exist.

Change Automation*

Change Automation is a way of automatically creating a consistent, systematic, and predictable way of managing change requests via controls and policies

https://learn.hashicorp.com/tutorials/terraform/automate-terraform
===========

Question 39
Which are valid places to store the API Token for authentication to Terraform Cloud or Terraform Enterprise?

Store the token on Terraform Cloud

SELECTED
This doesn't makes sense. You'd need an API token to access Terraform Cloud.

Use credentials_helpers to store the token elsewhere

SELECTED
If you would prefer not to store your API tokens directly in the CLI configuration as described in the previous section, you can optionally instruct Terraform to use a different credentials storage mechanism by configuring a special kind of plugin program called a credentials helper.

credentials_helper "example" {
  args = []
}
https://www.terraform.io/docs/cli/config/config-file.html#credentials-helpers

Store the API Token in credentials.tfrc.json

By default, Terraform will obtain an API token and save it in plain text in a local CLI configuration file called credentials.tfrc.json. When you run terraform login, it will explain specifically where it intends to save the API token and give you a chance to cancel if the current configuration is not as desired.

https://www.terraform.io/docs/cli/commands/login.html#credentials-storage

Store the API Token in the terraform.rc* SELECTED

Terraform Cloud provides a number of remote network services for use with Terraform, and Terraform Enterprise allows hosting those services inside your own infrastructure. For example, these systems offer both remote operations and a private module registry.

When interacting with Terraform-specific network services, Terraform expects to find API tokens in CLI configuration files in credentials blocks:

credentials "app.terraform.io" {
  token = "xxxxxx.atlasv1.zzzzzzzzzzzzz"
}
.terraformrc or terraform.rc are the same file.
===========

Question 40
Which Terraform Workflow ( Write -> Plan -> Create ) does this describe?

Initialize a terraform project locally, write code and commit it to a repo
When making changes commit each to the repo
Run terraform apply via your local CLI

Core Workflow Enhanced

Team Workflow

Individual Practitioner Workflow*
==============

Question 41
depends_on is only available for specific types of resource blocks?

True, dependson cannot be used with `nullresources`

False, It can be used with any kind of resource types

SELECTED
Use the depends_on meta-argument to handle hidden resource or module dependencies that Terraform can't automatically infer.

This argument is available in module blocks and in all resource blocks, regardless of resource type

https://www.terraform.io/docs/language/meta-arguments/depends_on.html
=======

Question 42
To write a save file plan to disk you will write terraform plan ______

it is not possible to write a save file plan to a custom path.

This is not true.

terraform plan path/to/file

terraform plan does not take a filepath as an argument without the -out flag.

-file=FILE

no such flag

-out=FILE

SELECTED
You can use the optional -out=FILE option to save the generated plan to a file on disk, which you can later execute by passing the file to terraform apply as an extra argument. This two-step workflow is primarily intended for when running Terraform in automation.

https://www.terraform.io/docs/cli/commands/plan.html
============

Question 43
In Terraform how would you explicitly determine the order of dependencies for multiple resources?

You can't explicitly set dependencies. Terraform automatically infers resources dependencies

Terraform does automatically infer resources dependencies but in some rare cases, you need to explicitly define dependencies using depends_on.

resource "aws_instance" "example" {
  # ....
  requires= [aws_s3_bucket.example]
}
resource "aws_instance" "example" {
  # ....
  depends= [aws_s3_bucket.example]
}
resource "aws_instance" "example" {
  # ....
  depends_on = [aws_s3_bucket.example]
}
SELECTED
You can use depends_on to explicitly declare the dependency.

https://learn.hashicorp.com/tutorials/terraform/dependencies
============

Question 44
You cannot source a module contained in a subdirectory within a Git repo

True

False

SELECTED
When the source of a module is a version control repository or archive file (generically, a "package"), the module itself may be in a sub-directory relative to the root of the package.

https://www.terraform.io/docs/language/modules/sources.html#modules-in-package-sub-directories

========

Question 45
A developer has deleted a database resource for Google Cloud that was being managed by a terraform state file.

What will happen when the developer runs terraform apply -refresh-only?

-refresh-only is not an available flag on apply, you need use to terraform refresh

terraform refresh and terraform apply -refresh-only -auto-approve are equivalent terraform refresh has be depercated.

terraform apply -refresh-only will simply print out to the CLI what has changed.

Terraform plan and apply will always show you what it will change, but not what has changed. the -refresh-only flag does not show a diff of current vs actual state.

The deleted database resource will be recreated

If you were to do a terraform apply without the -auto-refresh flag, this what would happen because terraform would think that you want to recreate the database since its missing.

The state file will be updated to reflect the change of the deleted resource

SELECTED
The purpose of terraform apply -refresh-only is when you want to update your statefile to reflect the actual state of the provider. This use-case is good for when someone has manually changed or deleted a resource and you want your state file updated.

https://www.terraform.io/docs/cli/commands/refresh.html

=========

Question 46
Is this a valid source for a module hosted on Github?

module "consul" {
  source = "github.com/hashicorp/example"
}
No, the Github source must be in this format:

git@github.com:hashicorp/example.git
Yes, the Github source must be in this format:

github.com/hashicorp/example
Yes, GitHub sources for modules support two formats:

github.com/hashicorp/example
git@github.com:hashicorp/example.git
SELECTED
https://www.terraform.io/docs/language/modules/sources.html#github

Terraform will recognize unprefixed github.com URLs and interpret them automatically as Git repository sources.

module "consul" {
  source = "github.com/hashicorp/example"
}
The above address scheme will clone over HTTPS. To clone over SSH, use the following form:

module "consul" {
  source = "git@github.com:hashicorp/example.git"
}
These GitHub schemes are treated as convenient aliases for the general Git repository address scheme, and so they obtain credentials in the same way and support the ref argument for selecting a specific revision. You will need to configure credentials in particular to access private repositories.
===========

Question 47
When we need to rename a resource what Terraform command should we use?

terraform mv

command does not exist

teraform resource rename

command does not exist

teraform rename

command does not exist

terraform state mv

SELECTED
https://www.terraform.io/docs/cli/commands/state/mv.html#example-rename-a-resource

Renaming a resource means making a configuration change like the following:

-resource "packet_device" "worker" {
+resource "packet_device" "helper" {
   # ...
 }
To tell Terraform that it should treat the new "helper" resource as a rename of the old "worker" resource, you can pair the above configuration change with the following command:

terraform state mv packet_device.worker packet_device.helper

============

Question 48
When Terraform crashes because Golang has resulted in a panic, also known as an error it will log the results to ________

terraform.log

panic.log

errrors.log

debug.log

crash.log*

If Terraform ever crashes (a "panic" in the Go runtime), it saves a log file with the debug logs from the session as well as the panic message and backtrace to crash.log

https://www.terraform.io/docs/internals/debugging.html#interpreting-a-crash-log
============

Question 49
A DevOps engineer is writing a terraform configuration script to provision a Linux Virtual Machine (VM). They want to be able to run arbitrary bash commands on the recently provisioned VM.

How should they configure the provisioner block within a resource?

It cannot be done

This is not true

use file provisioner

Flie provisioner is useful when you want to copy scripts or files to the target Virtual Machine

use local-exec provisioner

Local exec is when you want to run scripts or commands on the machine that is executing the order.

use remote-exec provisioner

SELECTED
remote-exec is for executing commands on the provisioned VM.

resource "aws_instance" "web" {
  # ...

  provisioner "remote-exec" {
    inline = [
      "puppet apply",
      "consul join ${aws_instance.web.private_ip}",
    ]
  }
}
https://www.terraform.io/docs/language/resources/provisioners/remote-exec.html
=========

Question 50
An AWS virtual machine has many attached EBS (virtual drives).

Using resource addressing and the splat operator, how could all the ids be returned?

aws_instance.example[*].ebs_block_device.id

There is only a single virtual machine, so using the splat operator here would not make sense.

aws_instance.example.ebs_block_device.id[*]

This would not make sense since the ebs_block_device is what he have multiple of, so we need to select all of them via ebs_block_device[*]

aws_instance.example.ebs_block_device.all.id

The splat operator is not being used all.

aws_instance.example.ebs_block_device[*].id CORRECT

The splat operator is the asterisk eg. (*)

The special [*] symbol iterates over all of the elements of the list given to its left and accesses from each one the attribute name given on its right.

https://www.terraform.io/docs/language/expressions/splat.html
==========

Question 51
The following terraform configuration is misconfigured, containing an invalid AMI ID.

resource "aws_instance" "my_example_server" {
  ami           = "NOT_A_VALID_AMI"
  instance_type = "t2.nano"
  tags = {
    Name = "MyExampleServer"
  }
}
Will terraform validate catch this invalid configuration?

Yes

No*

Terraform validate does not access remote services to determine if the configuration is correct. It determines if the syntax is correct.

So for example AMI is a required field by the AWS API. So if that was missing terraform validate would show that error.

But terraform validate would not know if the AMI is incorrect since it would have to make API calls to AWS to determine if the value is correct.

terraform validate would know it should expect a string, but it would not know if that string itself is valid.

https://www.terraform.io/docs/cli/commands/validate.html
============

Question 52
You can override the path to the terraform state file for a local backend

terraform {
  backend "local" {
    path = "relative/path/to/terraform.tfstate"
  }
}
False

True

SELECTED
Yes, you can.

https://www.terraform.io/docs/language/settings/backends/local.html#example-configuration
========

Question 53
Which of the following would define a remote backend to Amazon S3?

S3 cannot be used as a remote backend because it does not support locking

Remote backends sometimes support locking and others don't. S3 is a backend, supports locking, and not supporting locking would not be a reason for no support.

backend "s3" {
  region = "us-east-1"
}
When creating an S3 bucket it requires you specific a bucket and a key. Most remote backends will need to specify the location and file name.

backend "remote" {
  target = "s3"
  bucket = "my-terraform-state-bucket"
  key = "statefile"
  region = "us-east-1"
}
Remote is only used for Terraform cloud

backend "s3" {
  bucket = "my-terraform-state-bucket"
  key = "statefile"
  region = "us-east-1"
  }
  https://www.terraform.io/docs/language/settings/backends/s3.html
  =========

Question 54
Terraform Cloud does not have a free tier. For free you should use standard backends using third-party services like S3.

True

False

SELECTED
Terraform Cloud has a free tier for the 5 users of your team.

======

Question 55
Is Sentinel only available for Terraform Enterprise?

No, It's offered in the Business and Enterprise plan.

No, It's offered in the Teams, Business and Enterprise plan.

Yes, it's only available for Terraform Enterprise

No, It's offered in the Teams and Governance, Business and Enterprise plan.**

Sentinel starts at the Teams and Governance plan and is offered also in business. Its also offered within Terraform Enterprise.

https://www.datocms-assets.com/2885/1602500234-terraform-full-feature-pricing-tablev2-1.pdf
========

Question 56
How would you input the value of an input variable when using the CLI?

Use an environment variable starting with TF_VAR_

This is a valid option but the question is asking when using the CLI. The reason we want to use Env Vars is for Terraform Cloud runtime environment.

-variable=ec2_type="t2.medium"

There is no such flag as variable. The correct CLI flag is var

-var-file=ec2_type="t2.medium"

SELECTED
This is a real flag, but it's used for specifying a variable file to load

-var=ec2_type="t2.medium"

This is the correct anwser.

EXPLANATION
https://www.terraform.io/docs/language/values/variables.html#variable-definition-precedence

==========
Question 57
How can you mark a resource for replacement?

terraform resource replace

no such command

terraform state mv

This does not replace an instance

terraform replace

no such command

terraform apply -replace 
SELECTED

This is a new, safer way to replace a resource. This way is recommended because it allows you to review before replacing where terraform taint would auto approve.

terraform taint

SELECTED
Terraform deprecated in version v0.15.2. It might still show up in the exam because the exam is based on the last 3 versions of terraform.

https://www.terraform.io/docs/cli/commands/taint.html
========

















































































































































